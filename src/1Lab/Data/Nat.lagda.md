```agda
open import 1Lab.Data.Relation.Order
open import 1Lab.HLevel.Sets
open import 1Lab.Data.Dec
open import 1Lab.HLevel
open import 1Lab.Path
open import 1Lab.Type

module 1Lab.Data.Nat where
```

# Natural Numbers

The natural numbers are the inductive type generated by `zero`{.Agda}
and closed under taking `suc`{.Agda}cessors. Thus, they satisfy the
following induction principle, which is familiar:

```agda
Nat-elim : ∀ {ℓ} (P : Nat → Type ℓ)
         → P 0
         → ({n : Nat} → P n → P (suc n))
         → (n : Nat) → P n
Nat-elim P pz ps zero    = pz
Nat-elim P pz ps (suc n) = Nat-elim (λ z → P (suc z)) (ps pz) ps n
```

## Algebraic properties

Agda already provides definitions of `+`{.Agda} and `*`{.Agda}, but
not any properties of them. The proofs in this section should be
self-explanatory:

```agda
+-associative : (x y z : Nat) → (x + y) + z ≡ x + (y + z)
+-associative zero y z = refl
+-associative (suc x) y z =
  suc ((x + y) + z) ≡⟨ ap suc (+-associative x y z) ⟩
  suc (x + (y + z)) ∎

+-zeroʳ : (x : Nat) → x + 0 ≡ x
+-zeroʳ zero = refl
+-zeroʳ (suc x) =
  suc (x + 0) ≡⟨ ap suc (+-zeroʳ x) ⟩
  suc x       ∎

+-sucʳ : (x y : Nat) → x + suc y ≡ suc (x + y)
+-sucʳ zero y = refl
+-sucʳ (suc x) y = ap suc (+-sucʳ x y)

+-commutative : (x y : Nat) → x + y ≡ y + x
+-commutative zero y = sym (+-zeroʳ y)
+-commutative (suc x) y =
  suc (x + y) ≡⟨ ap suc (+-commutative x y) ⟩
  suc (y + x) ≡⟨ sym (+-sucʳ y x) ⟩
  y + suc x   ∎

*-distrib-+ʳ : (x y z : Nat) → (x + y) * z ≡ x * z + y * z
*-distrib-+ʳ zero y z = refl
*-distrib-+ʳ (suc x) y z =
  z + (x + y) * z     ≡⟨ ap₂ _+_ refl (*-distrib-+ʳ x y z) ⟩
  z + (x * z + y * z) ≡⟨ sym (+-associative z (x * z) (y * z)) ⟩
  z + x * z + y * z   ∎

*-sucʳ : (m n : Nat) → m * suc n ≡ m + m * n
*-sucʳ zero    n = refl
*-sucʳ (suc m) n =
  suc m * suc n         ≡⟨⟩
  suc n + m * suc n     ≡⟨ ap₂ _+_ refl (*-sucʳ m n) ⟩
  suc n + (m + m * n)   ≡⟨⟩
  suc (n + (m + m * n)) ≡⟨ ap suc (sym (+-associative n m (m * n))) ⟩
  suc (n + m + m * n)   ≡⟨ ap (λ x → suc (x + m * n)) (+-commutative n m) ⟩
  suc (m + n + m * n)   ≡⟨ ap suc (+-associative m n (m * n)) ⟩
  suc (m + (n + m * n)) ≡⟨⟩
  suc m + suc m * n     ∎

*-oneʳ : (x : Nat) → x * 1 ≡ x
*-oneʳ zero = refl
*-oneʳ (suc x) =
  suc (x * 1) ≡⟨ ap suc (*-oneʳ x) ⟩
  suc x       ∎

*-zeroʳ : (x : Nat) → x * 0 ≡ 0
*-zeroʳ zero = refl
*-zeroʳ (suc x) = *-zeroʳ x

*-commutative : (x y : Nat) → x * y ≡ y * x
*-commutative zero y    = sym (*-zeroʳ y)
*-commutative (suc x) y =
  y + x * y ≡⟨ ap₂ _+_ refl (*-commutative x y) ⟩
  y + y * x ≡⟨ sym (*-sucʳ y x) ⟩
  y * suc x ∎

*-distrib-+ˡ : (x y z : Nat) → z * (x + y) ≡ z * x + z * y
*-distrib-+ˡ x y z =
  z * (x + y)   ≡⟨ *-commutative z (x + y) ⟩
  (x + y) * z   ≡⟨ *-distrib-+ʳ x y z ⟩
  x * z + y * z ≡⟨ ap₂ _+_ (*-commutative x z) (*-commutative y z) ⟩
  z * x + z * y ∎

*-associative : (x y z : Nat) → (x * y) * z ≡ x * (y * z)
*-associative zero y z = refl
*-associative (suc x) y z =
  (y + x * y) * z     ≡⟨ *-distrib-+ʳ y (x * y) z ⟩
  y * z + (x * y) * z ≡⟨ ap₂ _+_ refl (*-associative x y z) ⟩
  y * z + x * (y * z) ∎
```

The exponentiation operator `^`{.Agda} is defined by recursion on the
exponent and satisfies its typical properties:

```agda
_^_ : Nat → Nat → Nat
x ^ zero = 1
x ^ suc y = x * (x ^ y)

infixr 8 _^_

^-oneʳ : (x : Nat) → x ^ 1 ≡ x
^-oneʳ x = *-oneʳ x

^-oneˡ : (x : Nat) → 1 ^ x ≡ 1
^-oneˡ zero = refl
^-oneˡ (suc x) =
  (1 ^ x) + 0 ≡⟨ +-zeroʳ (1 ^ x) ⟩
  (1 ^ x)     ≡⟨ ^-oneˡ x ⟩
  1 ∎

^-+-hom-*ʳ : (x y z : Nat) → x ^ (y + z) ≡ (x ^ y) * (x ^ z)
^-+-hom-*ʳ x zero z = sym (+-zeroʳ (x ^ z))
^-+-hom-*ʳ x (suc y) z =
  x * x ^ (y + z)     ≡⟨ ap (x *_) (^-+-hom-*ʳ x y z) ⟩
  x * (x ^ y * x ^ z) ≡⟨ sym (*-associative x (x ^ y) (x ^ z)) ⟩
  x * x ^ y * x ^ z ∎

^-distrib-*ʳ : (x y z : Nat) → (x * y) ^ z ≡ x ^ z * y ^ z
^-distrib-*ʳ x y zero = refl
^-distrib-*ʳ x y (suc z) = 
  x * y * (x * y) ^ z     ≡⟨ ap (λ a → x * y * a) (^-distrib-*ʳ x y z) ⟩
  x * y * (x ^ z * y ^ z) ≡⟨ sym (*-associative (x * y) (x ^ z) (y ^ z)) ⟩
  x * y * x ^ z * y ^ z   ≡⟨ ap (_* y ^ z) (*-associative x y (x ^ z)) ⟩
  x * (y * x ^ z) * y ^ z ≡⟨ ap (λ a → x * a * y ^ z) (*-commutative y (x ^ z)) ⟩
  x * (x ^ z * y) * y ^ z ≡⟨ ap (_* y ^ z) (sym (*-associative x (x ^ z) y)) ⟩
  x * x ^ z * y * y ^ z   ≡⟨ *-associative (x * x ^ z) y (y ^ z) ⟩
  x * x ^ z * (y * y ^ z) ∎

^-*-adjunct : (x y z : Nat) → (x ^ y) ^ z ≡ x ^ (y * z)
^-*-adjunct x zero z = ^-oneˡ z
^-*-adjunct x (suc y) zero = ^-*-adjunct x y zero
^-*-adjunct x (suc y) (suc z) =
  x * x ^ y * (x * x ^ y) ^ z       ≡⟨ ap (λ a → x * x ^ y * a) (^-distrib-*ʳ x (x ^ y) z) ⟩
  x * x ^ y * (x ^ z * (x ^ y) ^ z) ≡⟨ ap (λ a → x * x ^ y * (x ^ z * a)) (^-*-adjunct x y z) ⟩
  x * x ^ y * (x ^ z * x ^ (y * z)) ≡⟨ ap (λ a → x * x ^ y * a) (sym (^-+-hom-*ʳ x z (y * z))) ⟩
  x * x ^ y * (x ^ (z + (y * z)))   ≡⟨ *-associative x (x ^ y) (x ^ (z + y * z)) ⟩
  x * (x ^ y * (x ^ (z + (y * z)))) ≡⟨ ap (x *_) (sym (^-+-hom-*ʳ x y (z + y * z))) ⟩
  x * x ^ (y + (z + y * z))         ≡⟨ ap (λ a → x * x ^ a) (sym (+-associative y z (y * z))) ⟩
  x * x ^ (y + z + y * z)           ≡⟨ ap (λ a → x * x ^ (a + y * z)) (+-commutative y z) ⟩
  x * x ^ (z + y + y * z)           ≡⟨ ap (λ a → x * x ^ a) (+-associative z y (y * z)) ⟩
  x * x ^ (z + (y + y * z))         ≡⟨ ap (λ a → x * x ^ (z + a)) (sym (*-sucʳ y z))  ⟩
  x * x ^ (z + y * suc z) ∎
```


## Discreteness

A more interesting property of the natural numbers is that they are
_discrete_, i.e. there is a program that tells whether two naturals are
equal or not:

```agda
zero≠suc : {n : Nat} → zero ≡ suc n → ⊥
zero≠suc path = subst distinguish path tt where
  distinguish : Nat → Type
  distinguish zero = ⊤
  distinguish (suc x) = ⊥

suc-inj : {x y : Nat} → suc x ≡ suc y → x ≡ y
suc-inj = ap pred where
  pred : Nat → Nat
  pred (suc x) = x
  pred zero = zero

Discrete-Nat : Discrete Nat
Discrete-Nat zero zero = yes refl
Discrete-Nat zero (suc y) = no λ zero≡suc → absurd (zero≠suc zero≡suc)
Discrete-Nat (suc x) zero = no λ suc≡zero → absurd (zero≠suc (sym suc≡zero))
Discrete-Nat (suc x) (suc y) with Discrete-Nat x y
... | yes x≡y = yes (ap suc x≡y)
... | no ¬x≡y = no λ sucx≡sucy → ¬x≡y (suc-inj sucx≡sucy)
```

[Hedberg's theorem] implies that `Nat`{.Agda} is a [set].

[Hedberg's theorem]: agda://1Lab.HLevel.Sets#Discrete→isSet
[set]: agda://1Lab.HLevel#isSet

```agda
isSet-Nat : isSet Nat
isSet-Nat = Discrete→isSet Discrete-Nat
```

## Ordering

We define `_≤_`{.Agda} by recursion:

```agda
_≤_ : Nat → Nat → Type
zero ≤ zero = ⊤
zero ≤ suc y = ⊤
suc x ≤ zero = ⊥
suc x ≤ suc y = x ≤ y
```

Then we can prove it is reflexive, transitive and antisymmetric, making
it into a partial order:

```agda
≤-refl : (x : Nat) → x ≤ x
≤-refl zero = tt
≤-refl (suc x) = ≤-refl x

0≤x : (x : Nat) → zero ≤ x
0≤x zero = tt
0≤x (suc x) = tt

≤-trans : (x y z : Nat) → x ≤ y → y ≤ z → x ≤ z
≤-trans zero zero zero _ _          = tt
≤-trans zero zero (suc z) _ _       = tt
≤-trans zero (suc y) z p q          = 0≤x z
≤-trans (suc x) (suc y) (suc z) p q = ≤-trans x y z p q

≤-antisym : (x y : Nat) → x ≤ y → y ≤ x → x ≡ y
≤-antisym zero zero p q = refl
≤-antisym (suc x) (suc y) p q = ap suc (≤-antisym x y p q)

≤-prop : (x y : Nat) → isProp (x ≤ y)
≤-prop zero zero p q = refl
≤-prop zero (suc y) p q = refl
≤-prop (suc x) (suc y) p q = ≤-prop x y p q

≤-Preorder : isPreorder _≤_
≤-Preorder .isPreorder.reflexive {x} = ≤-refl x
≤-Preorder .isPreorder.transitive {x} {y} {z} = ≤-trans x y z
≤-Preorder .isPreorder.propositional {x} {y} = ≤-prop x y

≤-PartialOrder : isPartialOrder _≤_
≤-PartialOrder .isPartialOrder.preorder = ≤-Preorder
≤-PartialOrder .isPartialOrder.antisym {x} {y} = ≤-antisym x y
```

Furthermore, ≤ is decidable:

```agda
≤-flip : (x y : Nat) → (x ≤ y → ⊥) → y ≤ x
≤-flip zero zero ¬x≤y = tt
≤-flip zero (suc y) ¬x≤y = ¬x≤y tt
≤-flip (suc x) zero ¬x≤y = tt
≤-flip (suc x) (suc y) ¬x≤y = ≤-flip x y ¬x≤y

≤-dec : (x y : Nat) → Dec (x ≤ y)
≤-dec zero zero = yes tt
≤-dec zero (suc y) = yes tt
≤-dec (suc x) zero = no (λ z → z)
≤-dec (suc x) (suc y) = ≤-dec x y
```
