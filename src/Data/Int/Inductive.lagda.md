<!--
```
open import 1Lab.Equiv
open import 1Lab.Path
open import 1Lab.Type

open import Data.Dec.Base
open import Data.Nat.Base
```
-->

```agda
module Data.Int.Inductive where
```

# Inductive Integers

The **inductive integers** (or **built-in integers**) are the type
generated by the two constructors `pos`{.Agda} and `negsuc`{.Agda}, as
below. This type is important to have around because it is the type of
integers that Agda privileges as a built-in.

```agda
data Int : Type where
  pos    : Nat → Int
  negsuc : Nat → Int
{-# BUILTIN INTEGER       Int    #-}
{-# BUILTIN INTEGERPOS    pos    #-}
{-# BUILTIN INTEGERNEGSUC negsuc #-}
```

As the names indicate, these constructors are meant to represent a
`pos`{.Agda}itive integer, and the `negation of a successor`{.Agda
ident=negsuc} of a natural number, i.e. `negsuc`{.Agda} is the map
taking $n$ to $-(n + 1)$.

```agda
_ℕ-_ : Nat → Nat → Int
x     ℕ- zero  = pos x
zero  ℕ- suc y = negsuc y
suc x ℕ- suc y = x ℕ- y
```

<!--
```agda
pos-injective : ∀ {x y} → pos x ≡ pos y → x ≡ y
pos-injective = ap (case_of λ { (pos x) → x ; (negsuc _) → zero })

negsuc-injective : ∀ {x y} → negsuc x ≡ negsuc y → x ≡ y
negsuc-injective = ap (case_of λ { (pos x) → 0 ; (negsuc x) → x })

_ = Discrete-Nat
```
-->

We can decide equality of two `Int'`{.Agda}s by `comparing`{.Agda
ident=Discrete-Nat} their underlying naturals when the constructors
match (i.e. `pos`{.Agda}/`pos`{.Agda} or
`negsuc`{.Agda}/`negsuc`{.Agda}):

```agda
instance
  Discrete-Int : Discrete Int
  Discrete-Int {pos x} {pos y} with x ≡? y
  ... | yes p = yes (ap pos p)
  ... | no ¬p = no λ path → ¬p (pos-injective path)

  Discrete-Int {negsuc x} {negsuc y} with x ≡? y
  ... | yes p = yes (ap negsuc p)
  ... | no ¬p = no λ path → ¬p (negsuc-injective path)
```

And in case the constructors are mismatched, there can be no path
between them:

```agda
  Discrete-Int {pos x} {negsuc y} =
    let
      pos≠ns : pos x ≡ negsuc y → ⊥
      pos≠ns p = subst (λ { (pos x) → ⊤ ; (negsuc _) → ⊥ }) p tt
    in no pos≠ns
  Discrete-Int {negsuc x} {pos y} =
    let
      ns≠pos : negsuc x ≡ pos y → ⊥
      ns≠pos p = subst (λ { (pos x) → ⊥ ; (negsuc _) → ⊤ }) p tt
    in no ns≠pos
```

The integers are characterised as being the free type with an
equivalence. This equivalence is the successor function:

```agda
suc-int : Int → Int
suc-int (pos n)          = pos (suc n)
suc-int (negsuc zero)    = pos zero
suc-int (negsuc (suc n)) = negsuc n

pred-int : Int → Int
pred-int (pos zero)    = negsuc zero
pred-int (pos (suc n)) = pos n
pred-int (negsuc n)    = negsuc (suc n)

suc-pred : (x : Int) → suc-int (pred-int x) ≡ x
suc-pred (pos zero)    = refl
suc-pred (pos (suc x)) = refl
suc-pred (negsuc x)    = refl

pred-suc : (x : Int) → pred-int (suc-int x) ≡ x
pred-suc (pos x) = refl
pred-suc (negsuc zero) = refl
pred-suc (negsuc (suc x)) = refl

suc-equiv : Int ≃ Int
suc-equiv = Iso→Equiv (suc-int , iso pred-int suc-pred pred-suc)
```
