```agda
open import 1Lab.Prelude

module Data.Set.Quotient where
```

<!--
```agda
private variable
  ℓ ℓ' : Level
  A B : Type ℓ
  R S : A → A → Type ℓ
```
-->

# Set quotients

Let $A$ be a type (more commonly, this will be a set) and $R : A \to A
\to \ty$ be an equivalence relation valued in propositions. The
**quotient set** $A/R$ is intuitively the set obtained by "gluing
together" the elements of $A$ which are related by $R$. This can be
described more precisely in terms of a universal property: The quotient
$A/R$ is the coequalizer of the diagram

~~~{.quiver}
\[\begin{tikzcd}
  {\displaystyle\sum_{(x, y) : A \times A}R(x,y)} & A
  \arrow[shift left=1, from=1-1, to=1-2]
  \arrow[shift right=1, from=1-1, to=1-2]
\end{tikzcd}\]
~~~

Using a higher inductive type, we can define the quotient $A/R$ as the
type generated by a map $\mathrm{inc} : A \to A/R$, and identifying the
images of related objects. 

```agda
data _/_ (A : Type ℓ) (R : A → A → Type ℓ') : Type (ℓ ⊔ ℓ') where
  inc    : A → A / R
  quot   : ∀ x y → R x y → inc x ≡ inc y
```

However, since higher inductive types are _homotopy_ colimits, this does
not have the right [h-level] in general: The quotient $1/\top$ of the
unit type by the trivial relation ends up being [the circle], and not
the unit type. To address this, we throw in a constructor
`squash`{.Agda}, which asserts that the quotient is a set.

```agda
  squash : isSet (A / R)
```

[h-level]: 1Lab.HLevel.html
[the circle]: 1Lab.HIT.S1.html

The elimination rule for set-quotients says that you can make
(dependent) maps $A / R \to B$ out of (dependent) maps $f : A \to B$, as
long as $B$ is a (family of) set(s), and $f$ respects the equivalence
relation.

```agda
Quot-elim : ∀ {ℓ} {B : A / R → Type ℓ}
          → (∀ x → isSet (B x))
          → (f : ∀ x → B (inc x))
          → (∀ x y (r : R x y) → PathP (λ i → B (quot x y r i)) (f x) (f y))
          → ∀ x → B x
Quot-elim Bs bi br (inc x) = bi x
Quot-elim Bs bi br (quot x y r i) = br x y r i
Quot-elim Bs bi br (squash x y p q i j) =
  isHLevel→isHLevelDep 1 Bs 
    (g x) (g y) (λ i → g (p i)) (λ i → g (q i)) (squash x y p q) i j
  where g = Quot-elim Bs bi br
```

<!--
```agda
Quot-elimProp 
  : ∀ {ℓ} {B : A / R → Type ℓ}
  → (∀ x → isProp (B x))
  → (f : ∀ x → B (inc x))
  → ∀ x → B x
Quot-elimProp bp f = 
  Quot-elim (λ x → isProp→isSet (bp x)) f λ x y r i → 
    isProp→PathP (λ i → bp (quot x y r i)) (f x) (f y) i

Quot-rec : ∀ {ℓ} {B : Type ℓ}
         → isSet B
         → (f : A → B)
         → (∀ x y (r : R x y) → f x ≡ f y)
         → A / R → B
Quot-rec bs = Quot-elim (λ _ → bs)

Quot-rec₂ 
  : ∀ {ℓ} {C : Type ℓ}
  → isSet C
  → (f : A → B → C)
  → (∀ z x y (r : R x y) → f x z ≡ f y z)
  → (∀ z x y (r : S x y) → f z x ≡ f z y)
  → A / R → B / S → C
Quot-rec₂ cs f r1 r2 = 
  Quot-rec (isHLevel→ 2 cs) (λ x → Quot-rec cs (f x) (r2 x)) 
    (λ x y r → funext (Quot-elimProp (λ _ → cs _ _) λ e → r1 e x y r))
```
-->

## Effectivity

The most well-behaved case of quotients is when $R : A \to A \to \ty$
takes values in propositions, is reflexive, transitive and symmetric (an
equivalence relation). In this case, we have that the quotient $A / R$
is **effective**: The map `quot`{.Agda} is an equivalence.

```agda
module _ {A : Type ℓ} {R : A → A → Type ℓ'}
         (Rp : ∀ x y → isProp (R x y))
         (rr : ∀ {x} → R x x)
         (rt : ∀ {x y z} → R x y → R y z → R x z)
         (rs : ∀ {x y} → R x y → R y x)
  where
```

We will show this using an encode-decode method. For each $x : A$, we
define a type family $\mathrm{Code}_x(p)$, which represents an equality
$\mathrm{inc}(x) = y$. Importantly, the fibre over $\mathrm{inc}(y)$
will be $R(x, y)$, so that the existence of functions converting between
$\mathrm{Code}_x(y)$ and paths $\mathrm{inc}(x) = y$ is enough to
establish effectivity of the quotient.

```agda
  private
    Code : A → A / R → Prop ℓ'
    Code x = Quot-elim 
      (λ x → isHLevel-nType 1) 
      (λ y → {- 1 -} R x y , Rp x y)
      λ y z r → 
        Σ≡Prop (λ _ → isProp-isProp) 
          (ua {- 2 -} (propExt (Rp _ _) (Rp _ _) (λ z → rt z r) λ z → rt z (rs r)))
```

We do quotient induction into the `type of propositions`{.Agda
ident=Prop}, which by univalence `is a set`{.Agda ident=isHLevel-nType}.
Since the fibre over $\mathrm{inc}(y)$ must be $R(x, y)$, that's what we
give for the `inc`{.Agda} constructor (`{- 1 -}`{.Agda}, above). For
this to respect the quotient, it suffices to show that, given $R(y,z)$,
we have $R(x,y) \Leftrightarrow R(x,z)$, which follows from the
assumption that $R$ is an equivalence relation (`{- 2 -}`{.Agda}).

```agda
    encode : ∀ x y (p : inc x ≡ y) → Code x y .fst
    encode x y p = subst (λ y → Code x y .fst) p rr

    decode : ∀ x y (p : Code x y .fst) → inc x ≡ y
    decode x y p = 
      Quot-elimProp {B = λ y → (p : Code x y .fst) → inc x ≡ y} 
        (λ _ → isHLevelΠ 1 λ _ → squash _ _) (λ y r → quot _ _ r) y p
```

For `encode`{.Agda}, it suffices to transport the proof that $R$ is
reflexive along the given proof, and for decoding, we eliminate from the
quotient to a proposition. It boils down to establishing that $R(x,y)
\to \mathrm{inc}(x) \equiv \mathrm{inc}(y)$, which is what the
constructor `quot`{.Agda} says. Putting this all together, we get a
proof that equivalence relations are `effective`{.Agda}.

```agda
  effective : ∀ {x y : A} → isEquiv (quot {R = R} x y)
  effective {x = x} {y} = 
    propExt (Rp x y) (squash _ _) (decode x (inc y)) (encode x (inc y)) .snd 
```

## Universal property

As mentioned above, we expect that the inclusion $A \to A/R$ should
coequalise the two projections from the total space of $R$ to $A$.
Instead of actually defining what it means for a map to coequalise a
diagram of sets, we will unfurl this universal property to an equivalent
statement: For a set $B$, the space of maps $A/R \to B$ is equivalent to
the maps $A \to B$ which respect $R$.

```
Quot-univ : isSet B → (A / R → B) ≃ (Σ[ f ∈ (A → B) ] (∀ x y → R x y → f x ≡ f y))
Quot-univ Bset = Iso→Equiv isom where
  open isIso

  isom : Iso _ _
  isom .fst f = f ∘ inc , λ x y r i → f (quot x y r i)
  isom .snd .inv (f , r) = Quot-rec Bset f r
  isom .snd .rinv _ = refl
  isom .snd .linv f = funext (Quot-elimProp (λ _ → Bset _ _) λ x i → f (inc x))
```