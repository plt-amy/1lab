<!--
```agda
open import 1Lab.Reflection

open import Cat.Prelude

import Cat.Reasoning
```
-->

```agda
module Order.Base where
```

# Partially ordered sets {defines="poset partial-order partially-ordered-set"}

A **poset** (short for **p**artially **o**rdered set) is a [[set]]
equipped with a relation $x \le y$ which is reflexive, transitive and
antisymmetric. Put another way, a poset is a [[univalent category]],
which additionally satisfies the property that there is _at most one_
morphism inhabiting each $\hom$-set.

For convenience reasons, we prefer _not_ to work with the category
generated by a poset: the category associated with a poset reifies a lot
of _redundant_ information, which is necessary when working with
$\hom$-sets, but not with $\hom$-props. Working with the generated
category is analogous to only ever working with locally discrete
bicategories: you _could_, but then you'd be hauling around a bunch of
redundant information.

[univalent]: Cat.Univalent.html

Another reason to define posets as their own concept, rather than as a
special case of categories, is using our pre-existing infrastructure for
constructing very convenient categories of sets-with-structure; In this
case, sets with "po" structure!

We start by defining the _predicate_ `is-partial-order`{.Agda} on a
relation $x \le y$. That it turns out to be a predicate is actually
slightly nontrivial: The first four components are manifestly
propositional, but the last component --- the witness of antisymmetry
--- could really gunk things up, since it has the potential to assign
loops! But, given any antisymmetric relation $x \le y$, the family

$$
(x, y) \mapsto (x \le y) \land (y \le x)
$$

is an [[identity system]]^[Together with the unique evidence that this is a
reflexive relation] on $A$; and, being a product of propositions, it's
also a proposition, so $A$ is automatically a set.

```agda
record Poset o ℓ : Type (lsuc (o ⊔ ℓ)) where
  no-eta-equality
  field
    Ob : Type o
    _≤_ : Ob → Ob → Type ℓ
    ≤-thin    : ∀ {x y} → is-prop (x ≤ y)
    ≤-refl    : ∀ {x} → x ≤ x
    ≤-trans   : ∀ {x y z} → x ≤ y → y ≤ z → x ≤ z
    ≤-antisym : ∀ {x y} → x ≤ y → y ≤ x → x ≡ y

  opaque
    Ob-is-set : is-set Ob
    Ob-is-set =
      identity-system→hlevel 1
        {r = λ _ → ≤-refl , ≤-refl}
        (set-identity-system
          (λ a b → ×-is-hlevel 1 ≤-thin ≤-thin)
          (λ {a} {b} (p , q) → ≤-antisym {a} {b} p q))
        (λ a b → ×-is-hlevel 1 ≤-thin ≤-thin)
```

<!--
```agda
instance
  Underlying-Poset : ∀ {o ℓ} → Underlying (Poset o ℓ)
  Underlying-Poset .Underlying.ℓ-underlying = _
  Underlying-Poset .Underlying.⌞_⌟ = Poset.Ob

instance
  Poset-ob-hlevel-proj : hlevel-projection (quote Poset.Ob)
  Poset-ob-hlevel-proj .hlevel-projection.has-level = quote Poset.Ob-is-set
  Poset-ob-hlevel-proj .hlevel-projection.get-level _ = pure (lit (nat 2))
  Poset-ob-hlevel-proj .hlevel-projection.get-argument (_ ∷ _ ∷ arg _ t ∷ _) = pure t
  Poset-ob-hlevel-proj .hlevel-projection.get-argument _ = typeError []

  Poset-≤-hlevel-proj : hlevel-projection (quote Poset._≤_)
  Poset-≤-hlevel-proj .hlevel-projection.has-level = quote Poset.≤-thin
  Poset-≤-hlevel-proj .hlevel-projection.get-level _ = pure (lit (nat 1))
  Poset-≤-hlevel-proj .hlevel-projection.get-argument (_ ∷ _ ∷ arg _ t ∷ _) = pure t
  Poset-≤-hlevel-proj .hlevel-projection.get-argument _ = typeError []
```
-->

```agda
record Monotone
  {o o' ℓ ℓ'}
  (P : Poset o ℓ) (Q : Poset o' ℓ')
  : Type (o ⊔ o' ⊔ ℓ ⊔ ℓ')
  where
  no-eta-equality
  private
    module P = Poset P
    module Q = Poset Q
  field
    hom : P.Ob → Q.Ob
    pres-≤ : ∀ {x y} → x P.≤ y → hom x Q.≤ hom y

open Monotone public
```

<!--
```agda
private
  variable
    o ℓ o' ℓ' o'' ℓ'' : Level
    P Q R : Poset o ℓ

Monotone-is-hlevel : ∀ n → is-hlevel (Monotone P Q) (2 + n)
Monotone-is-hlevel {Q = Q} n =
  Iso→is-hlevel (2 + n) eqv $
  Σ-is-hlevel (2 + n) (Π-is-hlevel (2 + n) λ _ → is-set→is-hlevel+2 Q.Ob-is-set) λ _ →
  Π-is-hlevel' (2 + n) λ _ → Π-is-hlevel' (2 + n) λ _ → Π-is-hlevel (2 + n) λ _ →
  is-prop→is-hlevel-suc {n = suc n} Q.≤-thin
  where
    unquoteDecl eqv = declare-record-iso eqv (quote Monotone)
    module Q = Poset Q

instance
  H-Level-Monotone
    : ∀ {n}
    → H-Level (Monotone P Q) (2 + n)
  H-Level-Monotone = basic-instance 2 (Monotone-is-hlevel 0)

instance
  Funlike-Monotone : ∀ {o o' ℓ ℓ'} → Funlike (Monotone {o} {o'} {ℓ} {ℓ'})
  Funlike-Monotone .Funlike.au = Underlying-Poset
  Funlike-Monotone .Funlike.bu = Underlying-Poset
  Funlike-Monotone .Funlike._#_ = hom

Monotone-pathp
  : ∀ {o ℓ o' ℓ'} {P : I → Poset o ℓ} {Q : I → Poset o' ℓ'}
  → {f : Monotone (P i0) (Q i0)} {g : Monotone (P i1) (Q i1)}
  → PathP (λ i → ⌞ P i ⌟ → ⌞ Q i ⌟) (apply f) (apply g)
  → PathP (λ i → Monotone (P i) (Q i)) f g
Monotone-pathp q i .hom a = q i a
Monotone-pathp {P = P} {Q} {f} {g} q i .Monotone.pres-≤ {x} {y} α =
  is-prop→pathp
    (λ i → Π-is-hlevel³ {A = ⌞ P i ⌟} {B = λ _ → ⌞ P i ⌟} {C = λ x y → P i .Poset._≤_ x y} 1
      λ x y _ → Q i .Poset.≤-thin {q i x} {q i y})
    (λ _ _ α → f .Monotone.pres-≤ α)
    (λ _ _ α → g .Monotone.pres-≤ α) i x y α      

Extensional-Monotone
  : ∀ {o ℓ o' ℓ' ℓr} {P : Poset o ℓ} {Q : Poset o' ℓ'}
  → ⦃ sq : Extensional (⌞ Q ⌟) ℓr ⦄
  → Extensional (Monotone P Q) (o ⊔ ℓr)
Extensional-Monotone {Q = Q} ⦃ sq ⦄ =
  injection→extensional! Monotone-pathp (Extensional-→ ⦃ sq ⦄)

instance
  Extensionality-Monotone 
    : ∀ {o ℓ o' ℓ'} {P : Poset o ℓ} {Q : Poset o' ℓ'}
    → Extensionality (Monotone P Q)
  Extensionality-Monotone = record { lemma = quote Extensional-Monotone }
```
-->

```agda
idₘ : Monotone P P
idₘ .hom x = x
idₘ .pres-≤ x≤y = x≤y

_∘ₘ_ : Monotone Q R → Monotone P Q → Monotone P R
(f ∘ₘ g) .hom x = f # (g # x)
(f ∘ₘ g) .pres-≤ x≤y = f .pres-≤ (g .pres-≤ x≤y)

Posets : ∀ (o ℓ : Level) → Precategory (lsuc o ⊔ lsuc ℓ) (o ⊔ ℓ)
Posets o ℓ .Precategory.Ob = Poset o ℓ
Posets o ℓ .Precategory.Hom = Monotone
Posets o ℓ .Precategory.Hom-set = hlevel!
Posets o ℓ .Precategory.id = idₘ
Posets o ℓ .Precategory._∘_ = _∘ₘ_
Posets o ℓ .Precategory.idr f = trivial!
Posets o ℓ .Precategory.idl f = trivial!
Posets o ℓ .Precategory.assoc f g h = trivial!
```

<!--
```agda
module Posets {o ℓ} = Cat.Reasoning (Posets o ℓ)
```
-->

```agda
Forget-poset : ∀ {o ℓ} → Functor (Posets o ℓ) (Sets o)
∣ Forget-poset .Functor.F₀ P ∣ = ⌞ P ⌟
Forget-poset .Functor.F₀ P .is-tr = hlevel!
Forget-poset .Functor.F₁ = hom
Forget-poset .Functor.F-id = trivial!
Forget-poset .Functor.F-∘ _ _ = trivial!
```

```agda
_^opp : ∀ {ℓ ℓ'} → Poset ℓ ℓ' → Poset ℓ ℓ'
(P ^opp) .Poset.Ob = Poset.Ob P
(P ^opp) .Poset._≤_ x y = Poset._≤_ P y x
(P ^opp) .Poset.≤-thin = Poset.≤-thin P
(P ^opp) .Poset.≤-refl = Poset.≤-refl P
(P ^opp) .Poset.≤-trans x≥y y≥z = Poset.≤-trans P y≥z x≥y
(P ^opp) .Poset.≤-antisym x≥y y≥x = Poset.≤-antisym P y≥x x≥y
```
