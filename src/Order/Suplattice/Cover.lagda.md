<!--
```agda
open import 1Lab.Prelude

open import Data.Power

open import Order.Instances.Pointwise
open import Order.Diagram.Closure
open import Order.Suplattice
open import Order.Base

import Order.Reasoning as Pos
```
-->

```agda
module Order.Suplattice.Cover where
```

# Basic covers

::: note
The notion of basic cover we formalise is from the work of Ciraulo,
Maietti and Sambin [-@CMS:2012], who investigate it in a *predicative*
context. While the 1Lab globally assumes [[propositional resizing]],
relieving us of the predicativity concerns, the presentation by of
suplattices by basic covers is still useful in calculations.
:::

A **basic cover** is a particular method for presenting a [[suplattice]]
by _generators and relations_. The key observation behind the definition
is that the [[joins]] are central to the definition of the order in a
suplattice $S$: the entire order relation $x \le y$ is characterised by
the relation $x \le \bigvee U$, where $x : S$ and $U \sube S$.

In addition to having $x \le \bigvee U$ when $x \in U$, as demanded by
the universal property, we also have the following _transitivity_
condition: If $x \le \bigvee U$, and $\forall x \in U, x \le \bigvee V$,
then $x \le \bigvee V$. We abstract these properties into a relation $x
\ltri U$, [[proposition]]-valued, between an element $x : X$ and a
subset $U \sube S$.

```agda
record Basic-cover {ℓ} (S : Type ℓ) ℓ' : Type (ℓ ⊔ lsuc ℓ') where
  field
    _◂_         : S → ℙ S → Type ℓ'
    has-is-prop : ∀ {s U} → is-prop (s ◂ U)

  _◀_ : ℙ S → ℙ S → Type (ℓ ⊔ ℓ')
  U ◀ V = ∀ s → s ∈ U → s ◂ V

  field
    ◀-refl  : ∀ {s} {U : ℙ S}   → s ∈ U → s ◂ U
    ◀-trans : ∀ {s} {U V : ℙ S} → s ◂ U → U ◀ V → s ◂ V
```

Each basic cover determines a [[closure operator]] on the suplattice
$\bP(S)$ of subsets of $S$, where the closure of a subset $U \sube S$ is
the set $\{ a : A | a \ltri U \}$. Showing this is a closure operator,
while not literally immediate, is a short calculation away.

```agda
  open Closure

  closure : Closure (Subsets S)
  closure .close U a = elΩ (a ◂ U)
  closure .pres-≤ {U} {V} U⊆V a = map λ a◂U → ◀-trans a◂U λ s s∈U → ◀-refl (U⊆V s s∈U)
  closure .η U x∈U = inc (◀-refl x∈U)
  closure .μ {U} x □x◂jU = do
    x◂jU ← □x◂jU
    inc (◀-trans x◂jU λ s → out! {pa = has-is-prop})
```

## Recovering suplattices

In this section, we show that the relation in a basic cover really does
generalise the ordering in a suplattice, by showing that every
suplattice $P$ generates a basic cover --- and showing that this cover
presents the suplattice we started with.

<!--
```agda
module _ {o ℓ} {P : Poset o ℓ} (pl : is-suplattice P) where
  private module P = is-suplattice pl
  open Basic-cover hiding (closure)
  open Pos P
```
-->

This time, the calculation of the reflexivity and transitivity
conditions is immediate:

```agda
  suplattice→cover : Basic-cover Ob ℓ
  suplattice→cover ._◂_ s U         = s ≤ P.⋃ˢ U
  suplattice→cover .has-is-prop     = hlevel!
  suplattice→cover .◀-refl x∈U      = P.⋃ˢ-inj x∈U
  suplattice→cover .◀-trans x◂U U◀V = ≤-trans x◂U (P.⋃ˢ-universal U◀V)
```

<!--
```agda
  open Basic-cover suplattice→cover renaming (closure to j) using ()
  private
    module j = Closure j
    module Fj = Poset j.Fixposet
```
-->

We will refer to the closure operation induced by the semilattice $S$ as
$j : \bP(S) \to \bP(S)$. Since joins are uniquely determined --- thus
preserved by any isomorphism --- it will suffice to exhibit a
[[surjective|surjection]] [[order embedding]] $\bP(S)^j \to S$. Since a
basic cover treats subsets as _formal joins_, we can interpret them as
actual joins:

```agda
    to : j.Fixset → Ob
    to (s , _) = P.⋃ˢ s
```

To show that this is an order embedding, we can exhibit functions in
either direction. Since the ordering on $\bP(S)^j$ is subset inclusion,
it's automatic that $U \sube V$ implies $\bigvee U \le \bigvee V$. In
the other direction, we must make use of the fact that these are fixsets
of $j$. It follows that this operation is an injection.

```agda
    to-≤ : ∀ {U V} → U Fj.≤ V → to U ≤ to V
    to-≤ {U} {V} U⊆V = P.⋃ˢ-universal λ i x∈U →
      P.⋃ˢ-inj (U⊆V i x∈U)

    from-≤ : ∀ U V → to U ≤ to V → U Fj.≤ V
    from-≤ (U , uc) (V , vc) jU≤jV x x∈U = subst ∣_∣ (sym vc #ₚ x) $
      inc (≤-trans (P.⋃ˢ-inj x∈U) jU≤jV)
```

<!--
```agda
    to-inj : injective to
    to-inj {U} {V} p = Σ-prop-path! $ ext $ λ a → Ω-ua
      (from-≤ U V (≤-refl' p) a) (from-≤ V U (≤-refl' (sym p)) a)
```
-->

As an inverse, we choose the map that sends $l : S$ to $j(\downarrow
l)$, the $j$-closure of the principal down-set generated by $l$. The
join of this is precisely $l$, as we wanted!

```agda
    to-surj : is-surjective to
    to-surj l = pure $ j.unit (λ x → elΩ (x ≤ l)) , prf where abstract
      prf : to (j.unit (λ x → elΩ (x ≤ l))) ≡ l
      prf = ≤-antisym
        (P.⋃ˢ-universal λ i → □-rec! λ xul → ≤-trans xul (P.⋃ˢ-universal λ _ → out!))
        (P.⋃ˢ-inj (inc (P.⋃ˢ-inj (inc ≤-refl))))
```

Since an injective surjection between sets is an equivalence, we have an
equivalence between the sets $\bP(S)^j$ and $S$; we have also shown that
this equivalence is an order-embedding, so it must be an order
isomorphism.

```agda
  suplattice-is-presented : j.Fixset ≃ Ob
  suplattice-is-presented .fst = to
  suplattice-is-presented .snd = injective-surjective→is-equiv! to-inj to-surj
```
