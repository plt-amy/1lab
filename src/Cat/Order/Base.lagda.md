```agda
open import Cat.Displayed.Univalence.Thin
open import Cat.Prelude

module Cat.Order.Base where
```

# Partially ordered sets

A **poset** (short for **p**artially **o**rdered set) is a \r{set}
equipped with a relation $x \le y$ which is reflexive, transitive and
antisymmetric. Put another way, a poset is a [univalent] \r{category}
having at most one morphism between each pair of elements. For
convenience reasons, we prefer not to work directly with the category
generated by a poset: it contains a lot of redundant information (for
example, the witness of associativity). Working directly with the
generated category is analogous to only ever working with locally
discrete bicategories: you _could_, but then you'd be hauling around a
bunch of redundant information.

[univalent]: Cat.Univalent.html

```agda
record is-poset {ℓ ℓ′} {A : Type ℓ} (_≤_ : A → A → Type ℓ′) : Type (ℓ ⊔ ℓ′) where
  no-eta-equality
  field
    ≤-thin    : ∀ x y → is-prop (x ≤ y)
    ≤-refl    : ∀ x → x ≤ x
    ≤-trans   : ∀ x y z → x ≤ y → y ≤ z → x ≤ z
    ≤-antisym : ∀ x y → x ≤ y → y ≤ x → x ≡ y

  has-is-set : is-set A
  has-is-set =
    identity-system→hlevel 1
      {r = λ _ → ≤-refl _ , ≤-refl _}
      (set-identity-system
        (λ a b → ×-is-hlevel 1 (≤-thin a b) (≤-thin b a))
        (λ {a} {b} (p , q) → ≤-antisym a b p q))
      (λ a b → ×-is-hlevel 1 (≤-thin a b) (≤-thin b a))

private unquoteDecl eqv = declare-record-iso eqv (quote is-poset)

is-poset-is-prop
  : ∀ {ℓ ℓ′} {A : Type ℓ} (R : A → A → Type ℓ′) → is-prop (is-poset R)
is-poset-is-prop R x y = go x x y where
  go : is-poset R → is-prop (is-poset R)
  go x = Iso→is-hlevel 1 eqv $
    Σ-is-hlevel 1 (Π-is-hlevel² 1 λ _ _ → is-prop-is-prop) λ Rprop →
      ×-is-hlevel 1 (Π-is-hlevel 1 λ _ → Rprop _ _) $
      ×-is-hlevel 1 (Π-is-hlevel³ 1 λ _ _ _ → Π-is-hlevel² 1 λ _ _ → Rprop _ _) $
      Π-is-hlevel³ 1 λ _ _ _ → Π-is-hlevel 1 λ _ → is-poset.has-is-set x _ _


record Poset-on {ℓ} ℓ′ (A : Type ℓ) : Type (ℓ ⊔ lsuc ℓ′) where
  no-eta-equality
  field
    _≤_          : A → A → Type ℓ′
    has-is-poset : is-poset _≤_
  open is-poset has-is-poset public

Poset-structure : ∀ ℓ ℓ′ → Thin-structure {ℓ = ℓ} (ℓ ⊔ ℓ′) (Poset-on ℓ′)
∣ Poset-structure ℓ ℓ′ .is-hom f P Q ∣ =
  ∀ x y → Poset-on._≤_ P x y → Poset-on._≤_ Q (f x) (f y)

Poset-structure ℓ ℓ′ .is-hom f P Q .is-tr =
  Π-is-hlevel³ 1 λ _ _ _ → Poset-on.≤-thin Q _ _

Poset-structure ℓ ℓ′ .id-is-hom x y α = α
Poset-structure ℓ ℓ′ .∘-is-hom f g α β x y γ = α (g x) (g y) (β x y γ)

Poset-structure ℓ ℓ′ .id-hom-unique {s = s} {t = t} α β = q where
  module s = Poset-on s
  module t = Poset-on t
  open is-iso

  p : s._≤_ ≡ t._≤_
  p i x y = Glue (x t.≤ y) λ where
    (i = i0) → x s.≤ y , α x y , is-iso→is-equiv λ where
      .inv → β x y
      .rinv x → t.≤-thin _ _ _ _
      .linv x → s.≤-thin _ _ _ _
    (i = i1) → x t.≤ y , _ , id-equiv

  q : s ≡ t
  q i .Poset-on._≤_ = p i
  q i .Poset-on.has-is-poset = is-prop→pathp (λ i → is-poset-is-prop (p i))
    s.has-is-poset t.has-is-poset i

Posets : ∀ ℓ ℓ′ → Precategory (lsuc (ℓ ⊔ ℓ′)) (ℓ ⊔ ℓ′)
Posets ℓ ℓ′ = Structured-objects (Poset-structure ℓ ℓ′)

module Posets {ℓ ℓ′} = Precategory (Posets ℓ ℓ′)

module Poset {ℓ ℓ′} (P : Posets.Ob {ℓ} {ℓ′}) where
  open Poset-on (P .snd) public

  Ob : Type ℓ
  Ob = ⌞ P ⌟

  private variable
    w x y z : ⌞ P ⌟

  _≤⟨_⟩_ : (w : ⌞ P ⌟) → w ≤ x → x ≤ y → w ≤ y
  _=⟨_⟩_ : (w : ⌞ P ⌟) → w ≡ x → x ≤ y → w ≤ y
  _=˘⟨_⟩_ : (w : ⌞ P ⌟) → x ≡ w → x ≤ y → w ≤ y
  _≤∎    : (w : ⌞ P ⌟) → w ≤ w

  f ≤⟨ p ⟩ q = ≤-trans _ _ _ p q
  f =⟨ p ⟩ q = subst (_≤ _) (sym p) q
  f =˘⟨ p ⟩ q = subst (_≤ _) p q
  f ≤∎ = ≤-refl _

  infixr 2 _=⟨_⟩_ _=˘⟨_⟩_ _≤⟨_⟩_
  infix  3 _≤∎

open Precategory
```

The relationship between posets and (strict) categories is outlined in
the module [`Cat.Order.Cat`](Cat.Order.Cat.html).
