<!--
```agda
open import Cat.Instances.Shape.Terminal
open import Cat.Diagram.Colimit.Base
open import Cat.Instances.Elements
open import Cat.Site.Constructions
open import Cat.Functor.Kan.Base
open import Cat.Diagram.Sieve
open import Cat.Site.Closure
open import Cat.Functor.Hom
open import Cat.Site.Base
open import Cat.Prelude

import Cat.Reasoning as Cat
```
-->

```agda
module Cat.Site.Instances.Canonical {o ℓ} (C : Precategory o ℓ) where
```

# The canonical topology

<!--
```agda
open Element-hom
open Element
open Cat C
open _=>_
```
-->

Every [[sieve]] $S$ on an object $U$ (belonging to a category $\cC$) may
be regarded as a *diagram* in $\cC$, by first [[interpreting it as a
presheaf|sieves as presheaves]], then considering the projection functor

$$
\pi : \int S \to \cC
$$

having domain $S$'s [[category of elements]]. This process automatically
makes $U$ into a [[cocone]] under the diagram generated by $S$, so that
we may ask: is $U$ the colimit of $S$?

```agda
sieve→cocone : ∀ {U} (S : Sieve C U) → πₚ C (to-presheaf S) => Const U
sieve→cocone S .η (elem _ (f , _)) = f
sieve→cocone S .is-natural (elem _ (f , _)) (elem _ (g , _)) h =
  g ∘ h .hom ≡⟨ ap fst (h .commute) ⟩
  f          ≡⟨ introl refl ⟩
  id ∘ f     ∎

is-colim : ∀ {U} → Sieve C U → Type _
is-colim {U} S = is-colimit _ U (sieve→cocone S)
```

Johnstone [-@Elephant, C2.2.8] refers to the sieves which *are*
colimiting cocones as "effective-epimorphic". We will instead follow
Lester [-@Lester:2019] and refer to them as **colim sieves**.

```agda
is-universal-colim : ∀ {U} → Sieve C U → Type _
is-universal-colim {U} S =
  ∀ {V} (f : Hom V U) → is-colim (pullback f S)

abstract
  is-universal-colim-is-stable
    : ∀ {U V} (f : Hom V U) (S : Sieve C U)
    → is-universal-colim S
    → is-universal-colim (pullback f S)
  is-universal-colim-is-stable f S hS g = subst is-colim pullback-∘ (hS (f ∘ g))

Canonical-coverage : Coverage C (o ⊔ ℓ)
Canonical-coverage = from-stable-property
  is-universal-colim
  is-universal-colim-is-stable

patch→cocone
  : ∀ {U V} (S : Sieve C U)
  → Patch (Hom-into C V) S
  → πₚ C (to-presheaf S) => const! V F∘ !F
patch→cocone S p .η (elem _ (f , hf)) = p .part f hf
patch→cocone S p .is-natural (elem _ (f , hf)) (elem _ (g , hg)) h =
  p .part g hg ∘ h .hom  ≡⟨ p .patch g hg (h .hom) (S .closed hg (h .hom)) ⟩
  p .part (g ∘ h .hom) _ ≡⟨ app p (ap fst (h .commute)) ⟩
  p .part f _            ≡⟨ introl refl ⟩
  id ∘ p .part f _       ∎

is-universal-colim→よ-is-sheaf
  : ∀ {U V} (S : Sieve C U)
  → is-universal-colim S
  → is-sheaf₁ (Hom-into C V) S
is-universal-colim→よ-is-sheaf {U} {V} S colim p = uniq where
  module x = is-lan (colim id)

  nt : πₚ C (to-presheaf (pullback id S)) => const! V F∘ !F
  nt = patch→cocone (pullback id S) (subset→patch (λ f → subst (_∈ S) (idl _)) p)

  s : Section _ p
  s .part       = x.σ nt .η tt
  s .patch f hf =
      x.σ-comm {α = nt} ηₚ elem _ (f , subst (_∈ S) (introl refl) hf)
    ∙ app p refl

  uniq : is-contr (Section _ p)
  uniq .centre  = s
  uniq .paths x = ext (x.σ-uniq {α = nt} {σ' = σ'} (ext λ i → sym (x .patch _ _)) ηₚ tt) where
    σ' : const! U => const! V
    σ' .η _ = x .part
    σ' .is-natural _ _ _ = id-comm

representable-is-sheaf-canonical
  : ∀ {U} → is-sheaf Canonical-coverage (Hom-into C U)
representable-is-sheaf-canonical .has-sheaf₁ (S , hS) =
  is-universal-colim→よ-is-sheaf S hS

is-subcanonical→is-universal-colim
  : ∀ {ℓc} (J : Coverage C ℓc)
  → (∀ {V} → is-sheaf J (Hom-into C V))
  → ∀ {U} {c : J .covers U} → is-universal-colim (J .cover c)
is-subcanonical→is-universal-colim J shf {U} {c} {V} f = to-is-colimitp mk refl where
  open make-is-colimit

  mk : make-is-colimit (πₚ C (to-presheaf (pullback f (J .cover c)))) V
  mk .ψ (elem V' (g , hg)) = g
  mk .commutes f = ap fst (f .commute)
  mk .universal {W} eps comm = sec .centre .part module univ where
    p : Patch (よ₀ C W) (pullback f (J .cover c))
    p .part {X} g hg = eps (elem X (g , hg))
    p .patch f hf g hgf = comm (elem-hom g (Σ-prop-path! refl))

    sec = is-sheaf-pullback shf c f p

  mk .factors {j} eps comm = univ.sec eps comm .centre .patch _ _
  mk .unique eps comm other p = sym $ ap part $ univ.sec eps comm .paths
    record { patch = λ f hf → p (elem _ (f , hf)) }
```
