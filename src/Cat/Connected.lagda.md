<!--
```agda
open import Cat.Instances.StrictCat.Cohesive
open import Cat.Instances.Shape.Terminal
open import Cat.Instances.FreeGroupoid
open import Cat.Diagram.Terminal
open import Cat.Diagram.Initial
open import Cat.Prelude

open Precategory
open Congruence
open Functor
```
-->

```agda
module Cat.Connected where
```

# Connected categories {defines="connected-category"}

A [[precategory]] is **connected** if it has exactly one [[connected component]].
Explicitly, this means that it has at least one object, and that every two objects
can be connected by a finite [[zigzag]] of morphisms.

```agda
record is-connected-cat {o ℓ} (C : Precategory o ℓ) : Type (o ⊔ ℓ) where
  no-eta-equality
  field
    point : ∥ Ob C ∥
    zigzag : ∀ x y → ∥ Zigzag C x y ∥
```

<!--
```agda
open is-connected-cat

private unquoteDecl eqv = declare-record-iso eqv (quote is-connected-cat)

instance
  H-Level-is-connected-cat
    : ∀ {k o ℓ} {C : Precategory o ℓ}
    → H-Level (is-connected-cat C) (1 + k)
  H-Level-is-connected-cat = basic-instance 1 (Iso→is-hlevel 1 eqv (hlevel 1))
```
-->

As a simple example, a category is connected if it has an initial
or terminal object. In particular, the [[terminal category]] is connected
^[but the [[initial category]] isn't].

```agda
⊤Cat-is-connected : is-connected-cat ⊤Cat
⊤Cat-is-connected .point = inc tt
⊤Cat-is-connected .zigzag _ _ = inc nil

module _ {o ℓ} {C : Precategory o ℓ} where
  open Precategory C

  initial→connected : Initial C → is-connected-cat C
  initial→connected init = conn where
    open Initial init
    conn : is-connected-cat C
    conn .point = inc bot
    conn .zigzag x y = inc (cons⁻¹ ¡ (cons ¡ nil))

  terminal→connected : Terminal C → is-connected-cat C
  terminal→connected term = conn where
    open Terminal term
    conn : is-connected-cat C
    conn .point = inc top
    conn .zigzag x y = inc (cons ! (cons⁻¹ ! nil))
```

We now show that this definition is equivalent to asking for the set of
[[connected components]] $\pi_0(\cC)$ to be [[contractible]].
The forward implication easily follows from the elimination principle of
zigzags into sets:

```agda
  connected→π₀-is-contr : is-connected-cat C → is-contr ∣ π₀ C ∣
  connected→π₀-is-contr conn = ∥-∥-rec!
    (λ x → contr (inc x)
      (Coeq-elim-prop (λ _ → hlevel 1)
        λ y → ∥-∥-rec! (Zigzag-elim-set (π₀ C) inc quot)
          (conn .zigzag x y)))
    (conn .point)
```

Showing the converse implication is not as straightforward: in order to go from
paths in $\pi_0(\cC)$ to zigzags, we would like to use the [[effectivity]] of
quotients, but the $\hom$ relation is not a [[congruence]]^[it is not in general
symmetric or valued in propositions]!

Luckily, we can define the *free* congruence generated by $\hom$: two objects
are related by this congruence if there merely exists a zigzag between them
^[vaguely thinking of `Zigzag`{.Agda} as the reflexive, transitive and symmetric
closure of `Hom`{.Agda}].
We can then show that the [[quotient]] of this congruence is equivalent to
$\pi_0(\cC)$, allowing us to conclude.

```agda
  π₀-is-contr→connected : is-contr ∣ π₀ C ∣ → is-connected-cat C
  π₀-is-contr→connected π₀-contr = conn where
    R : Congruence (Ob C) (o ⊔ ℓ)
    R ._∼_ x y = ∥ Zigzag C x y ∥
    R .has-is-prop _ _ = squash
    R .reflᶜ = inc nil
    R ._∙ᶜ_ = ∥-∥-map₂ _++_
    R .symᶜ = ∥-∥-map reverse

    is : Iso (quotient R) ∣ π₀ C ∣
    is .fst = Coeq-rec squash inc λ (x , y , fs) →
      ∥-∥-rec (squash _ _) (Zigzag-elim-set (π₀ C) inc quot) fs
    is .snd .is-iso.inv = Coeq-rec squash inc λ (x , y , f) →
      quot (inc (cons f nil))
    is .snd .is-iso.rinv = Coeq-elim-prop (λ _ → squash _ _) λ _ → refl
    is .snd .is-iso.linv = Coeq-elim-prop (λ _ → squash _ _) λ _ → refl

    conn : is-connected-cat C
    conn .point = Coeq-elim-prop (λ _ → squash) inc (π₀-contr .centre)
    conn .zigzag x y = effective R
      (is-contr→is-prop (Iso→is-hlevel 0 is π₀-contr) (inc x) (inc y))

  connected≃π₀-is-contr : is-connected-cat C ≃ is-contr ∣ π₀ C ∣
  connected≃π₀-is-contr = prop-ext (hlevel 1) (hlevel 1)
    connected→π₀-is-contr π₀-is-contr→connected
```
